<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Comment utiliser les mathématiques…</title>
    <meta charset="utf-8" />
    <meta name="author" content="Marc-André Désautels" />
    <script src="libs/header-attrs/header-attrs.js"></script>
    <link href="libs/remark-css/default.css" rel="stylesheet" />
    <link href="libs/remark-css/default-fonts.css" rel="stylesheet" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# Comment utiliser les mathématiques…
## … pour imprimer en 3D
### <a href="https://madesautels.rbind.io">Marc-André Désautels</a>
### Cégep Saint-Jean-sur-Richelieu
### Octobre 2022 <br><br> Présentation disponible à <a href="https://desautm.github.io/Imprimante3D" class="uri">https://desautm.github.io/Imprimante3D</a> <br> Code disponible à <a href="https://github.com/desautm/Imprimante3D" class="uri">https://github.com/desautm/Imprimante3D</a>

---




class: center, middle

&lt;iframe width="800" height="600" src="https://www.youtube.com/embed/m_QhY1aABsE" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen&gt;&lt;/iframe&gt;

---
class:inverse, middle, center

# Quelques rappels

---

# TODO...

- Équation de droite `\(\overrightarrow{\textbf{r}}=\overrightarrow{\textbf{r}_0}+t\overrightarrow{\textbf{v}}\)`

- Équation du plan

- Intersection droite avec plan (seulement savoir si il y a intersection et ensuite trouver l'intersection)

- Trouver distance point-droite

- Est-ce qu'un point est au-dessus ou au-dessous d'une droite?

---
class: inverse, center, middle

# Une modélisation 3D d'un objet

---
class: center, inverse

background-image: url("https://i.stack.imgur.com/ENvMe.png")
background-size: contain
---

# STL pour STéréoLitographie

- Ce format ne comporte notamment pas d'informations concernant la couleur, la texture ou les autres paramètres habituels d'un modèle de conception assistée par ordinateur.

- Le **format de fichier STL** ne décrit que la géométrie de surface d'un objet en 3 dimensions.

- Cette surface est nécessairement fermée et définie par une série de triangles (ou de facettes). 

- Chaque triangle est défini par les coordonnées cartésiennes (x, y, z) dans un trièdre direct de son vecteur normal unitaire (n) orienté vers l'extérieur de l'objet et de ses trois sommets (vertex/vertices en anglais) ordonnés dans le sens trigonométrique. 

- Chaque triangle doit partager 2 sommets avec chacun des triangles le juxtaposant. Dit autrement, le sommet d'un triangle ne doit pas être sur l'arête d'un autre triangle. Il n'y a pas d'information d'échelle. 

- L'unité de longueur est arbitraire.

---

# Le format de fichier STL

.pull-left[
facet normal `\(n_x\)` `\(n_y\)` `\(n_z\)`

outer loop

vertex `\(v_{1_x}\)` `\(v_{1_y}\)` `\(v_{1_z}\)`

vertex `\(v_{2_x}\)` `\(v_{2_y}\)` `\(v_{2_z}\)`

vertex `\(v_{3_x}\)` `\(v_{3_y}\)` `\(v_{3_z}\)`

end loop

end facet
]

.pull-right[
&lt;img src="index_files/figure-html/triangle-with-vertex-normal-1.png" style="display: block; margin: auto;" /&gt;
]

---
class:middle, center

![toto](http://www.ams.org/images/fcarc-march2014-trunccube.jpg)

---
class:middle, center

![toto](http://www.ams.org/images/fcarc-march2014-slice.zonotope.small.jpg)
---
class: inverse, center, middle

# Couper le solide en polygones

---

# On veut trouver l'intersection d'un plan avec le solide

- Le solide est composé de plusiers triangles.

- Chaque triangle est composé de trois segments de droites.

- On veut donc savoir si un segment de droite croise le plan.

---
class: middle, center

![](index_files/figure-html/unnamed-chunk-1-1.png)&lt;!-- --&gt;

---
class: middle, center

![](index_files/figure-html/unnamed-chunk-2-1.png)&lt;!-- --&gt;

---
class: middle, center

![](index_files/figure-html/unnamed-chunk-3-1.png)&lt;!-- --&gt;

---
class: middle, center

![](index_files/figure-html/unnamed-chunk-4-1.png)&lt;!-- --&gt;

---
class: middle, center

![](index_files/figure-html/unnamed-chunk-5-1.png)&lt;!-- --&gt;

---
class: middle, center

![](index_files/figure-html/unnamed-chunk-6-1.png)&lt;!-- --&gt;

---
class: middle, center

![](index_files/figure-html/unnamed-chunk-7-1.png)&lt;!-- --&gt;

---
class: middle, center

![](index_files/figure-html/unnamed-chunk-8-1.png)&lt;!-- --&gt;

---
class: middle, center

![](index_files/figure-html/unnamed-chunk-9-1.png)&lt;!-- --&gt;

---
class: middle, center

![](index_files/figure-html/unnamed-chunk-10-1.png)&lt;!-- --&gt;

---
class: inverse, center, middle

# Simplifier des droites

---
class:middle, center
![](index_files/figure-html/unnamed-chunk-11-1.png)&lt;!-- --&gt;
---
class:middle, center
![](index_files/figure-html/unnamed-chunk-12-1.png)&lt;!-- --&gt;
---
class:middle, center
![](index_files/figure-html/unnamed-chunk-13-1.png)&lt;!-- --&gt;
---
class:middle, center
![](index_files/figure-html/unnamed-chunk-14-1.png)&lt;!-- --&gt;
---
class:middle, center
![](index_files/figure-html/unnamed-chunk-15-1.png)&lt;!-- --&gt;
---
class:middle, center
![](index_files/figure-html/unnamed-chunk-16-1.png)&lt;!-- --&gt;
---
class:middle, center
![](index_files/figure-html/unnamed-chunk-17-1.png)&lt;!-- --&gt;
---
class:middle, center
![](index_files/figure-html/unnamed-chunk-18-1.png)&lt;!-- --&gt;
---
class:middle, center
![](index_files/figure-html/unnamed-chunk-19-1.png)&lt;!-- --&gt;

---
class:middle, center

![Animation de l'algorithme pour simplifier une droite](simplify_line.gif)

---
class: inverse, center, middle

# Géométrie de construction de solides (ou GCS)

---

# Géométrie de construction de solides (ou GCS)

- La GCS permet de représenter simplement un ensemble de points et de travailler ensuite avec ceux-ci à l'intérieur d'un programme informatique;

- La GCS considère que tous les ensembles sont construits à partir d'ensembles **plus simples**, qui font office de blocs de construction;

- Certaines règles simples permettent ensuite d'échafauder des structures complexes.

---

# La représentation GCS d'un polygone

- Nous utiliserons des demi-plans pour représenter un polygone;

- Les règles de construction utilisées seront les mêmes que celles des ensembles:

  - Le complément;
  
  - L'union;
  
  - L'intersection

- Une droite orientée définit un demi-plan `\(H\)` se trouvant à gauche de la droite lorsqu'on se déplace dans la direction définit par l'orientation.

---
class: center, middle

![](index_files/figure-html/unnamed-chunk-20-1.png)&lt;!-- --&gt;

Nous pouvons voir `\(H\)` comme une fonction booléenne sur le plan: `\(H(p)=\textbf{VRAI}\)` si et seulement si `\(p\in H\)`.

---

# Le complément

![](index_files/figure-html/unnamed-chunk-21-1.png)&lt;!-- --&gt;

---

# L'union

![](index_files/figure-html/unnamed-chunk-22-1.png)&lt;!-- --&gt;

---

# L'intersection

![](index_files/figure-html/unnamed-chunk-23-1.png)&lt;!-- --&gt;

---

# La différence

![](index_files/figure-html/unnamed-chunk-24-1.png)&lt;!-- --&gt;

---
class: inverse, center, middle

# Enveloppe convexe

---

# L'enveloppe convexe

- L'enveloppe convexe d'un objet ou d'un regroupement d'objets géométriques est l'ensemble convexe le plus petit parmi ceux qui le contiennent.

- Dans un plan, l'enveloppe convexe peut être comparée à la région limitée par un élastique qui englobe tous les points qu'on relâche jusqu'à ce qu'il se contracte au maximum. L'idée serait la même dans l'espace avec un ballon qui se dégonflerait jusqu'à être en contact avec tous les points qui sont à la surface de l'enveloppe convexe.

---
class:middle, center, inverse

# L'algorithme QuickHull


---
class: center, middle
![](index_files/figure-html/unnamed-chunk-25-1.png)&lt;!-- --&gt;

---
class: center, middle
![](index_files/figure-html/unnamed-chunk-26-1.png)&lt;!-- --&gt;

---
class: center, middle
![](index_files/figure-html/unnamed-chunk-27-1.png)&lt;!-- --&gt;

---
class: center, middle
![](index_files/figure-html/unnamed-chunk-28-1.png)&lt;!-- --&gt;

---
class: center, middle
![](index_files/figure-html/unnamed-chunk-29-1.png)&lt;!-- --&gt;

---
class: center, middle
![](index_files/figure-html/unnamed-chunk-30-1.png)&lt;!-- --&gt;

---
class: center, middle
![](index_files/figure-html/unnamed-chunk-31-1.png)&lt;!-- --&gt;

---
class: center, middle
![](index_files/figure-html/unnamed-chunk-32-1.png)&lt;!-- --&gt;

---
class: center, middle
![](index_files/figure-html/unnamed-chunk-33-1.png)&lt;!-- --&gt;

---
class: center, middle
![](index_files/figure-html/unnamed-chunk-34-1.png)&lt;!-- --&gt;

---
class: center, middle
![](index_files/figure-html/unnamed-chunk-35-1.png)&lt;!-- --&gt;

---
class: middle, center

&lt;img src="quickhull.gif" width="75%" /&gt;


    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
